#!/usr/bin/env python

from analyze import *
from config import *
from find import *
from logparse import *
from logproc import *
from output import *
from processed import *
from print import *
import argparse
import logging
import os
import sys

logging.basicConfig(format='[+] %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

proc_taint_log_file = './processed_log/proc_taint_log.json'
proc_taint_var_log_file = './processed_log/proc_taint_var_log.json'
proc_memaccess_log_file = './processed_log/proc_memaccess_log.json'
proc_heap_alloc_log_file = './processed_log/proc_heap_alloc_log.json'


def main():
    parser = argparse.ArgumentParser(
        prog='STAGE-BJJ',
        description='A tool that dynamically analyzes script engines to obtain information of implementation details.',
        epilog=''
    )
    parser.add_argument('log_file', help='a log file generated by Tracer-BJJ.')
    parser.add_argument('config_file', help='a JSON-formatted config file for STAGER-BJJ.')
    parser.add_argument('-o', '--output', default='config_out.json', help='an output config file name for Extractor-BJJ.')
    args = parser.parse_args()

    logger.info('Reading a log file: {}'.format(args.log_file))

    try:
        with open(args.log_file, 'rb') as f:
            log_content = f.read()
    except FileNotFoundError:
        logger.error('No such file {}'.format(args.log_file))
        sys.exit()
    except Exception as e:
        logger.error('Unexpected error occurred: {}'.format(e))
        sys.exit()

    logger.info('Done')

    logger.info('Loading a config file: {}'.format(args.config_file))

    config = load_config(args.config_file)
    if not is_config_valid(config):
        logger.error('Invalid config')
        sys.exit()

    logger.info('Done.')

    if os.path.isfile(proc_taint_log_file):
        logger.info('Processed taint log file exists. Loading: {}'.format(proc_taint_log_file))
        taint_log = load_proc_taint_log_from_json(proc_taint_log_file)
        logger.info('Done.')
    else:
        logger.info('Parsing taint log...')
        taint_log = parse_taint_log(log_content)
        save_proc_taint_log_to_json(taint_log, proc_taint_log_file)
        logger.info('Done.')

    if os.path.isfile(proc_memaccess_log_file):
        logger.info('Processed memory access log file exists. Loading: {}'.format(proc_memaccess_log_file))
        memaccess_log = load_proc_log_from_json(proc_memaccess_log_file)
        logger.info('Done.')
    else:
        logger.info('Parsing memory access log...')
        memaccess_log = parse_tainted_memaccess_log(log_content, taint_log)
        save_proc_log_to_json(memaccess_log, proc_memaccess_log_file)
        logger.info('Done.')

    if os.path.isfile(proc_heap_alloc_log_file):
        logger.info('Processed heap allocation log file exists. Loading: {}'.format(proc_heap_alloc_log_file))
        heap_alloc_log = load_proc_log_from_json(proc_heap_alloc_log_file)
        logger.info('Done.')
    else:
        logger.info('Parsing heap allocation log...')
        heap_alloc_log = parse_heap_alloc_log(log_content)
        save_proc_log_to_json(heap_alloc_log, proc_heap_alloc_log_file)
        logger.info('Done.')

    # unify_addr_bak(taint_log, memaccess_log)
    print_taint_src_reg_values(taint_log)
    # detect_arg_struct_semantics(taint_log)

    # struct_log = consolidate_log_into_struct(taint_log)
    if os.path.isfile(proc_taint_var_log_file):
        logger.info('Processed tainted variable log file exists. Loading: {}'.format(proc_taint_var_log_file))
        taint_var_log = load_proc_taint_var_log_from_json(proc_taint_var_log_file)
        logger.info('Done.')
    else:
        logger.info('Rebuilding tained variables...')
        taint_var_log = consolidate_bytes_into_var(taint_log, memaccess_log)
        save_proc_taint_var_log_to_json(taint_var_log, proc_taint_var_log_file)
        logger.info('Done.')

    structs = build_struct(memaccess_log)
    arrays = build_array(memaccess_log)

    reg_values = get_reg_values(taint_log)

    init_taint_var_log = generate_init_var_log(taint_var_log, memaccess_log)

    target_vals = []
    for target_val in config['characteristic_values']:
        if isinstance(target_val, str):
            heap_bufs = reconstruct_heap_buf(taint_log, heap_alloc_log)
            found_bufs = find_symtable_buf(heap_bufs, target_val)

            for buf in found_bufs:
                target_vals.append(buf['base'])
        else:
            target_vals.append(target_val)

    trees = []
    paths = []
    for target_val in target_vals:
        logger.info('Search target: {}'.format(hex(target_val)))

        addrs = get_var_addr(init_taint_var_log, target_val)
        if len(addrs) == 0:
            logger.error('Search target {} not found.'.format(hex(target_val)))
            continue
        addr = addrs[0]
        logger.info('Search target {} found at {}.'.format(hex(target_val), hex(addr)))

        tree = build_struct_tree(structs, init_taint_var_log, addr)

        for reg, reg_val in reg_values.items():
            path = get_struct_ref_path(tree, reg_val)

            if path is not None:
                buf = 'Found reference path: {}'.format(reg.upper())
                for node in path:
                    buf = '{} ({}, +{})'.format(buf, hex(node.struct.base), hex(node.offset))
                logger.info(buf)

                logger.info('====================')
                for node in path:
                    print_node(node)
                logger.info('====================')

                trees.append(tree)
                paths.append(path)

    for tree, path in zip(trees, paths):
        ref = build_ref_info(tree, path, reg_values)
        logger.info(ref)

    with open(args.output, 'w') as f:
        f.write(dump_output_config(ref, config))
 

if __name__ == '__main__':
    main()